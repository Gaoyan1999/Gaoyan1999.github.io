(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{363:function(n,t,i){"use strict";i.r(t);var e=i(44),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"pat-preparation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#pat-preparation"}},[n._v("#")]),n._v(" PAT Preparation")]),n._v(" "),i("blockquote",[i("p",[n._v("高频英语单词")])]),n._v(" "),i("p",[n._v("non-decreasing order  非降序")]),n._v(" "),i("p",[n._v("alphanumerical characters  字母数字字符")]),n._v(" "),i("p",[n._v("lexicographically  字典序")]),n._v(" "),i("p",[n._v("Quadratic probing: 平方探测法、若有冲突则加平方（1，4，9……）")]),n._v(" "),i("p",[n._v("capital English letters 大写字母")]),n._v(" "),i("p",[n._v("pre/in/Post order 前、中、后")]),n._v(" "),i("p",[n._v("polynomials  多项式")]),n._v(" "),i("p",[n._v("Exponents and coefficients  指数和系数")]),n._v(" "),i("h2",{attrs:{id:"tip-for-c"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tip-for-c"}},[n._v("#")]),n._v(" tip for c++")]),n._v(" "),i("ul",[i("li",[n._v("进制转换")])]),n._v(" "),i("p",[n._v("将⼗进制 a 转换为 b 进制数，当 a 不等于 0 时，将 a%b 从后往前倒序保存下来，每次保存后 将 a/b 。这样倒序保存的数就是⼗进制 a 在 b 进制下的结果。")]),n._v(" "),i("ul",[i("li",[n._v("辗转相除求公约数")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("int gcd(int a,int b){\n\treturn b ==0 ? a:gcd(b,a%b);\n}\n")])])]),i("ul",[i("li",[n._v("⼤数组必须开全局")])]),n._v(" "),i("h3",{attrs:{id:"string-操作"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#string-操作"}},[n._v("#")]),n._v(" String 操作")]),n._v(" "),i("ul",[i("li",[n._v("读入一行操作")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("string s;\ngetline(cin,s);\n")])])]),i("ul",[i("li",[n._v("判断字符串")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("#include<cctype>\nisalnum  是字母数字\nisalpha 是字母\nisdigit 是数字\nisupper 是大写字母\nislower 是小写字母\nisblank 是空格/table\nisspace 是空格回车\n  \n")])])]),i("ul",[i("li",[n._v("字符串转int")])]),n._v(" "),i("div",{staticClass:"language-java extra-class"},[i("pre",{pre:!0,attrs:{class:"language-java"}},[i("code",[n._v("a2"),i("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),i("span",{pre:!0,attrs:{class:"token function"}},[n._v("atoi")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("p2"),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),i("span",{pre:!0,attrs:{class:"token function"}},[n._v("c_str")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n")])])]),i("ul",[i("li",[i("p",[n._v("判断char[] 长度  strlen(a)")])]),n._v(" "),i("li",[i("p",[n._v("截取")])])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('string s ="01234";\ns.substr(1,2);//12\ns.substr(0,1);//0\n')])])]),i("h3",{attrs:{id:"pair-操作"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#pair-操作"}},[n._v("#")]),n._v(" pair  操作")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('typedef pair<string,int> p;\nvector<p> v;\np temp=make_pair("abc",123);//insert\ntemp.first   temp.second//get\n\n')])])]),i("h3",{attrs:{id:"queue"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[n._v("#")]),n._v(" Queue")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("q.push();\nq.front();//look up the first element\nq.pop(); //delete  top\n")])])]),i("h3",{attrs:{id:"set"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[n._v("#")]),n._v(" Set")]),n._v(" "),i("ul",[i("li",[n._v("基本操作")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("s.find(num)!=s.end();\ns.insert(1);\n")])])]),i("ul",[i("li",[n._v("Get")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("set<int>::iterator it=s.begin();\ncout<<*it;\n")])])]),i("ul",[i("li",[n._v("求交集")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("#include <algorithm>\n\nset<int> inter;\nset<int> a;\nset<int> b;\nset_intersection(a.begin(),a.end(),b.begin(),b.end(),inserter(inter,inter.begin()));\n\n")])])]),i("h2",{attrs:{id:"题型分类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#题型分类"}},[n._v("#")]),n._v(" 题型分类")]),n._v(" "),i("h3",{attrs:{id:"dfs-➕树-图"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dfs-➕树-图"}},[n._v("#")]),n._v(" DFS ➕树 /图")]),n._v(" "),i("ol",[i("li",[i("a",{attrs:{href:"https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944",target:"_blank",rel:"noopener noreferrer"}},[n._v("1090 Highest Price in Supply Chain"),i("OutboundLink")],1)])]),n._v(" "),i("blockquote",[i("p",[n._v("该题要求构建一个树结构, 求出树的深度，并输出最深的")])]),n._v(" "),i("p",[n._v("超时的代码：如果我们每次都遍历数组，会由于走了许多已经访问过的路而超时")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N =100010;\nint arr[N];\nbool vis[N];\nint main(){\n    int n;\n    float p,r;\n    cin>>n;\n    cin>>p>>r;\n        int k =0;\n    for(int i=0;i<n;i++){\n        cin>>arr[i];   \n        if(arr[i]==-1)  vis[i] =1;\n        \n    }\n    int sum=1;\n\n    int deep = 0;\n    while(sum < n){\n         k=0;\n        deep++;\n         vector<int> idx;\n        for(int i=0;i<n;i++){\n            if(vis[i]) continue;           \n           if(vis[arr[i]]==true) {\n               k++;\n                idx.push_back(i);\n           }\n        }\n\n        for(auto x: idx) {vis[x] =true;}\n        sum +=k;\n    }\n      \n  \tfloat  res = p;\n\t  r =r/100+1;\n    while(deep--){\n        res *= r;\n    }\n    \n    printf("%.2f %d\\n",res,k);\n    \n}\n')])])]),i("p",[n._v("AC 代码:使用一个二维数组来保存每个节点的子节点")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int N =100010;\nint arr[N];\nvector<int> tree[N];\n\nint maxDeep =0,temp=0;\nvoid dfs(int root,int deep){\n     if(deep==maxDeep){\n         temp++;         \n     }else if(deep >maxDeep){\n         maxDeep = deep;\n         temp=1;\n     }\n\n\n    for(int x : tree[root]){\n        dfs(x,deep+1);\n    }\n}\n\nint main(){\n    int n;\n    double p,r;\n    cin>>n;\n    cin>>p>>r;\n\n    int root =-1;\n    for(int i=0;i<n;i++){\n           int j;\n            cin>>j;\n        if(j == -1) root = i;\n      else   tree[j].push_back(i);\n    }\n        \n    dfs(root,0);\n    \n\n    \n    printf("%.2f %d\\n",p * pow((1+r/100),maxDeep),temp);\n    \n}\n')])])]),i("h3",{attrs:{id:"bfs"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#bfs"}},[n._v("#")]),n._v(" BFS")]),n._v(" "),i("p",[i("a",{attrs:{href:"https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072",target:"_blank",rel:"noopener noreferrer"}},[n._v("1091 Acute Stroke"),i("OutboundLink")],1)]),n._v(" "),i("blockquote",[i("p",[n._v("经典的BFS题目，只是此题是个三维的～。给到一个三维矩阵，找出大于某个阈值的连通块，求出所有连通块的和")])]),n._v(" "),i("p",[n._v("tips: 使用向量来简化方向的判断")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <queue>\nusing namespace std;\nstruct node {\n    int x, y, z;\n};\nint m, n, l, t;\nint X[6] = {1, 0, 0, -1, 0, 0};\nint Y[6] = {0, 1, 0, 0, -1, 0};\nint Z[6] = {0, 0, 1, 0, 0, -1};\nint arr[1300][130][80];\nbool vis[1300][130][80];\nbool judge(int x, int y, int z) {\n if(x<0||x>=m||y<0||y>=n||z<0||z>=l) return false;\n  if(arr[x][y][z]==0 || vis[x][y][z]) return false;\n  return true;\n}\nint bfs(int x, int y, int z) {\n  \tint cnt =0;\n    node temp;\n    temp.x =x ,temp.y=y,temp.z=z;\n    queue<node> qq;\n    vis[x][y][z]=true;\n    qq.push(temp);\n    while(!qq.empty()){\n  \t\tnode top = qq.front();\n     \tqq.pop();\n      cnt++;\n      for(int i=0;i<6;i++){\n        int tx= top.x + X[i];\n        int ty= top.y + Y[i];\n        int tz= top.z + Z[i];\n        if(judge(tx,ty,tz)){\n          vis[tx][ty][tz]=true;\n          temp.x =tx ,temp.y=ty,temp.z=tz;\n          qq.push(temp);\n        }\n      }\n    }\n  if(cnt >=t){\n    return cnt;\n  }else {\n    return 0;\n  }\n}\nint main() {\n    scanf("%d %d %d %d", &m, &n, &l, &t);\n    for(int i = 0; i < l; i++)\n        for(int j = 0; j < m; j++)\n            for(int k = 0; k < n; k++)\n                scanf("%d", &arr[j][k][i]);\n    int ans = 0;\n    for(int i = 0; i < l; i++) {\n        for(int j = 0; j < m; j++) {\n            for(int k = 0; k < n; k++) {\n                if(arr[j][k][i] == 1 && vis[j][k][i] == false)\n                    ans += bfs(j, k, i);\n            }\n        }\n    }\n    printf("%d", ans);\n    return 0;\n}\n')])])]),i("p",[i("a",{attrs:{href:"https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048",target:"_blank",rel:"noopener noreferrer"}},[n._v("1094 The Largest Generation "),i("OutboundLink")],1)]),n._v(" "),i("p",[n._v("输出树中节点最多的层级以及节点的个数（经典BFS）")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int N = 110;\nvector<int> child[N];\n\nint level =0,max_generation=0;\n\nvoid bfs(int l){\n  queue<int> q;\n  q.push(1);\n  while(!q.empty()){\n   int length = q.size();\n    l ++;\n    if(length > max_generation){\n      max_generation = length;\n      level =l;      \n    }\n    for(int i=0;i<length;i++){\n      int top =q.front();\n      q.pop();\n      for(int cd:child[top]){\n        q.push(cd);\n      }\n    }\n  }\n  \n}\n\nint main (){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int node,k;\n    cin>>node>>k;\n    while(k--){\n      int cd;\n      cin>>cd;\n      child[node].push_back(cd);\n    }\n  }\n  \n  bfs(0);\n  cout<<max_generation <<" "<<level<<endl;\n  \n}\n')])])]),i("h3",{attrs:{id:"stl-操作"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#stl-操作"}},[n._v("#")]),n._v(" STL 操作")]),n._v(" "),i("p",[i("a",{attrs:{href:"https://pintia.cn/problem-sets/994805342720868352/problems/994805371602845696",target:"_blank",rel:"noopener noreferrer"}},[n._v("1095 Cars on Campus "),i("OutboundLink")],1)]),n._v(" "),i("p",[n._v("统计时间，map、vector 的使用，字典排序")]),n._v(" "),i("p",[n._v("Tips：")]),n._v(" "),i("ul",[i("li",[n._v("string 建议用char * 代替")]),n._v(" "),i("li",[n._v("时间操作")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace  std;\n\n\nconst int N = 10010;\nstruct node{\n    char s[10];\n    int time;\n    int in;\n};\n\nbool cmp( node r1, node  r2){\n    if(strcmp(r1.s,r2.s) != 0) return strcmp(r1.s,r2.s) <0;\n    else return r1.time<r2.time;\n}\n\nbool cmp2(node a,node b){\n    return a.time<b.time;\n}\n\nint main(){\n    int n,k,maxtime = -1,tempindex=0;\n    cin>>n>>k;\n    vector<node> record(n),car;\n    for(int i=0;i<n;i++){\n        char  in[5];\n        int h,m,ss;\n        scanf("%s %d:%d:%d %s\\n",record[i].s,&h,&m,&ss,in);\n        int time = h*3600 + m*60 + ss;\n        record[i].time =time ;\n        record[i].in =  strcmp(in,"in")== 0  ?1:-1;\n    }\n    sort(record.begin(),record.end(),cmp);\n\n    map<string,int> mapp;\n    for(int i=0;i<n-1;i++){\n        if(strcmp(record[i].s,record[i+1].s)==0  && record[i].in==1 && record[i+1].in==-1){\n            //match\n            car.push_back(record[i]);\n            car.push_back(record[i+1]);\n            mapp[record[i].s] += (record[i+1].time-record[i].time);\n            if(maxtime < mapp[record[i].s]) {\n              maxtime =   mapp[record[i].s];\n            }\n        }\n    }\n    sort(car.begin(),car.end(),cmp2);\n    vector<int> cnt(n);\n    for(int i=0;i<car.size();i++){\n        if(i==0){\n            cnt[i] = car[i].in;\n        }else {\n            cnt[i] =cnt[i-1]+ car[i].in;\n        }\n    }\n\n    for(int i=0;i<k;i++){\n        int h, m, s;\n        scanf("%d:%d:%d", &h, &m, &s);\n        int temptime = h * 3600 + m * 60 + s;\n        int j;\n        for(j=tempindex;j<car.size();j++){\n            if(car[j].time > temptime){\n                printf("%d\\n",cnt[j-1]);\n                break;\n            }else if(j==car.size()-1){\n                printf("%d\\n",cnt[j]);\n            }\n        }\n        tempindex =j;\n\n    }\n    for(map<string, int>::iterator it = mapp.begin(); it != mapp.end(); it++) {\n        if(it->second == maxtime)\n            printf("%s ", it->first.c_str());\n    }\n    printf("%02d:%02d:%02d", maxtime / 3600, (maxtime % 3600) / 60, maxtime % 60);\n    return 0;\n\n\n}\n')])])]),i("ol",{attrs:{start:"1068"}},[i("li",[n._v("找硬币（背包 贪心问题）")])]),n._v(" "),i("h2",{attrs:{id:"djikstra"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#djikstra"}},[n._v("#")]),n._v(" Djikstra")]),n._v(" "),i("blockquote",[i("p",[n._v("Djik 算法在找到某个点最小路径后，不会存在任何路径，小于等于这个值。所以不会再对该点进行任何操作")])]),n._v(" "),i("ul",[i("li",[i("p",[n._v("Dijk 保存路径")])]),n._v(" "),i("li",[i("p",[n._v("Dijk 求路径个数   (PAT Emergency 1003)")])])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint matrix[510][510];\nbool vis[510] = {false};\nint rescue[510];\nint dist[510];\nconst int MAX = 9999999999;\nint main() {\n    int n, m;\n    int start, end;\n    cin >> n >> m;\n    cin >> start >> end;\n    for (int i = 0; i < n; i++) scanf("%d", &rescue[i]);\n    fill(matrix[0], matrix[0] + 510 * 510, MAX);\n    for (int i = 0; i < n; i++) matrix[i][i] = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        matrix[a][b] = matrix[b][a] = c;\n    }\n    int visit = n - 1;\n    vis[start] = 1;\n    for (int i = 0; i < n; i++) dist[i] = matrix[start][i];\n    int teams[n];\n    int paths[n];\n    for(int i=0;i<n;i++){\n        if(matrix[start][i]<MAX && i!=start) {\n            paths[i]=1;\n            teams[i]=rescue[i]+rescue[start];\n        }else{\n            paths[i]=0;\n        }\n    }\n    paths[start]=1;\n    teams[start]=rescue[start];\n    while (true) {\n        int minIndex = -1;\n        int min = MAX;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == false && dist[i] < min) {\n                minIndex = i;\n                min = dist[i];\n            }\n        }\n        vis[minIndex] = true;\n        visit--;\n        if (visit<=0) break;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == false) {\n                if (dist[i] > dist[minIndex] + matrix[minIndex][i]) {\n                    dist[i]=dist[minIndex] + matrix[minIndex][i];\n                    paths[i]=paths[minIndex];\n                    teams[i]=teams[minIndex]+rescue[i];\n                }else if(dist[i] == dist[minIndex] + matrix[minIndex][i]){\n                    paths[i]+=paths[minIndex];\n                    if(teams[i]<teams[minIndex]+rescue[i]) teams[i]=teams[minIndex]+rescue[i];\n                }\n            }\n        }\n    }\n    cout << paths[end]<<" "<<teams[end];\n}\n')])])]),i("h2",{attrs:{id:"并查集"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[n._v("#")]),n._v(" 并查集")]),n._v(" "),i("ul",[i("li",[n._v("找父节点，并且压缩")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("int findFather(int x){\n  int t=x;\n\twhile(x!=fa[x]) x=fa[x];\n  // 优化压缩\n\twhile(t!=fa[t]){\n    int z=t;\n    t=fa[t];\n    fa[z]=x;\n  }\n  return x;\n}\n")])])]),i("ul",[i("li",[n._v("合并")])]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("void Union(int a,int b){\n  int faA=findFather(a);\n  int faB=findFather(b);\n if(faA!=faB) fa[faA]=faB;\n}\n")])])]),i("ul",[i("li",[i("p",[n._v("1076  深搜  超时")])]),n._v(" "),i("li",[i("p",[n._v("并查集")])]),n._v(" "),i("li",[i("p",[n._v("Dfs 1079")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);